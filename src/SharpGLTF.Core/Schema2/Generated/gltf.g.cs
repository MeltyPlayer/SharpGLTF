// <auto-generated/>

//------------------------------------------------------------------------------------------------
//      This file has been programatically generated; DONÂ´T EDIT!
//------------------------------------------------------------------------------------------------

#pragma warning disable SA1001
#pragma warning disable SA1027
#pragma warning disable SA1028
#pragma warning disable SA1121
#pragma warning disable SA1205
#pragma warning disable SA1309
#pragma warning disable SA1402
#pragma warning disable SA1505
#pragma warning disable SA1507
#pragma warning disable SA1508
#pragma warning disable SA1652

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Numerics;
using System.Text.Json;

using JSONREADER = System.Text.Json.Utf8JsonReader;
using JSONWRITER = System.Text.Json.Utf8JsonWriter;
using FIELDINFO = SharpGLTF.Reflection.FieldInfo;


namespace SharpGLTF.Schema2
{
	using Collections;

	/// <summary>
	/// The indices data type.
	/// </summary>
	public enum IndexEncodingType
	{
		UNSIGNED_BYTE = 5121,
		UNSIGNED_SHORT = 5123,
		UNSIGNED_INT = 5125,
	}


	/// <summary>
	/// The datatype of the accessor's components.
	/// </summary>
	public enum EncodingType
	{
		BYTE = 5120,
		UNSIGNED_BYTE = 5121,
		SHORT = 5122,
		UNSIGNED_SHORT = 5123,
		UNSIGNED_INT = 5125,
		FLOAT = 5126,
	}


	/// <summary>
	/// Specifies if the accessor's elements are scalars, vectors, or matrices.
	/// </summary>
	public enum DimensionType
	{
		SCALAR,
		VEC2,
		VEC3,
		VEC4,
		MAT2,
		MAT3,
		MAT4,
		CUSTOM,
	}


	/// <summary>
	/// The name of the node's TRS property to animate, or the <see cref="weights"/> of the Morph Targets it instantiates. For the <see cref="translation"/> property, the values that are provided by the sampler are the translation along the X, Y, and Z axes. For the <see cref="rotation"/> property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the <see cref="scale"/> property, the values are the scaling factors along the X, Y, and Z axes.
	/// </summary>
	public enum PropertyPath
	{
		translation,
		rotation,
		scale,
		weights,
		pointer,
	}


	/// <summary>
	/// Interpolation algorithm.
	/// </summary>
	public enum AnimationInterpolationMode
	{
		LINEAR,
		STEP,
		CUBICSPLINE,
	}


	/// <summary>
	/// The hint representing the intended GPU buffer type to use with this buffer view.
	/// </summary>
	public enum BufferMode
	{
		ARRAY_BUFFER = 34962,
		ELEMENT_ARRAY_BUFFER = 34963,
	}


	/// <summary>
	/// Specifies if the camera uses a perspective or orthographic projection.
	/// </summary>
	public enum CameraType
	{
		perspective,
		orthographic,
	}


	/// <summary>
	/// The alpha rendering mode of the material.
	/// </summary>
	public enum AlphaMode
	{
		OPAQUE,
		MASK,
		BLEND,
	}


	/// <summary>
	/// The topology type of primitives to render.
	/// </summary>
	public enum PrimitiveType
	{
		POINTS = 0,
		LINES = 1,
		LINE_LOOP = 2,
		LINE_STRIP = 3,
		TRIANGLES = 4,
		TRIANGLE_STRIP = 5,
		TRIANGLE_FAN = 6,
	}


	/// <summary>
	/// Magnification filter.
	/// </summary>
	public enum TextureInterpolationFilter
	{
		NEAREST = 9728,
		LINEAR = 9729,
		DEFAULT = 0,
	}


	/// <summary>
	/// Minification filter.
	/// </summary>
	public enum TextureMipMapFilter
	{
		NEAREST = 9728,
		LINEAR = 9729,
		NEAREST_MIPMAP_NEAREST = 9984,
		LINEAR_MIPMAP_NEAREST = 9985,
		NEAREST_MIPMAP_LINEAR = 9986,
		LINEAR_MIPMAP_LINEAR = 9987,
		DEFAULT = 0,
	}


	/// <summary>
	/// T (V) wrapping mode.
	/// </summary>
	public enum TextureWrapMode
	{
		CLAMP_TO_EDGE = 33071,
		MIRRORED_REPEAT = 33648,
		REPEAT = 10497,
	}


	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class LogicalChildOfRoot : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "glTFChildOfRootProperty";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "name";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "name": value = FIELDINFO.From("name",this, instance => instance._name); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private String _name;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "name", _name);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "name": DeserializePropertyValue<LogicalChildOfRoot, String>(ref reader, this, out _name); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// An object pointing to a buffer view containing the indices of deviating accessor values. The number of indices is equal to `accessor.sparse.count`. Indices **MUST** strictly increase.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class AccessorSparseIndices : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "indices";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "bufferView";
			yield return "byteOffset";
			yield return "componentType";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "bufferView": value = FIELDINFO.From("bufferView",this, instance => instance._bufferView); return true;
				case "byteOffset": value = FIELDINFO.From("byteOffset",this, instance => instance._byteOffset ?? 0); return true;
				case "componentType": value = FIELDINFO.From("componentType",this, instance => instance._componentType); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32 _bufferView;
		
		private const Int32 _byteOffsetDefault = 0;
		private const Int32 _byteOffsetMinimum = 0;
		private Int32? _byteOffset = _byteOffsetDefault;
		
		private IndexEncodingType _componentType;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "bufferView", _bufferView);
			SerializeProperty(writer, "byteOffset", _byteOffset, _byteOffsetDefault);
			SerializePropertyEnumValue<IndexEncodingType>(writer, "componentType", _componentType);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "bufferView": DeserializePropertyValue<AccessorSparseIndices, Int32>(ref reader, this, out _bufferView); break;
				case "byteOffset": DeserializePropertyValue<AccessorSparseIndices, Int32?>(ref reader, this, out _byteOffset); break;
				case "componentType": _componentType = DeserializePropertyValue<IndexEncodingType>(ref reader); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// An object pointing to a buffer view containing the deviating accessor values. The number of elements is equal to `accessor.sparse.count` times number of components. The elements have the same component type as the base accessor. The elements are tightly packed. Data **MUST** be aligned following the same rules as the base accessor.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class AccessorSparseValues : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "values";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "bufferView";
			yield return "byteOffset";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "bufferView": value = FIELDINFO.From("bufferView",this, instance => instance._bufferView); return true;
				case "byteOffset": value = FIELDINFO.From("byteOffset",this, instance => instance._byteOffset ?? 0); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32 _bufferView;
		
		private const Int32 _byteOffsetDefault = 0;
		private const Int32 _byteOffsetMinimum = 0;
		private Int32? _byteOffset = _byteOffsetDefault;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "bufferView", _bufferView);
			SerializeProperty(writer, "byteOffset", _byteOffset, _byteOffsetDefault);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "bufferView": DeserializePropertyValue<AccessorSparseValues, Int32>(ref reader, this, out _bufferView); break;
				case "byteOffset": DeserializePropertyValue<AccessorSparseValues, Int32?>(ref reader, this, out _byteOffset); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Sparse storage of accessor values that deviate from their initialization value.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class AccessorSparse : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "sparse";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "count";
			yield return "indices";
			yield return "values";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "count": value = FIELDINFO.From("count",this, instance => instance._count); return true;
				case "indices": value = FIELDINFO.From("indices",this, instance => instance._indices); return true;
				case "values": value = FIELDINFO.From("values",this, instance => instance._values); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const Int32 _countMinimum = 1;
		private Int32 _count;
		
		private AccessorSparseIndices _indices;
		
		private AccessorSparseValues _values;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "count", _count);
			SerializePropertyObject(writer, "indices", _indices);
			SerializePropertyObject(writer, "values", _values);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "count": DeserializePropertyValue<AccessorSparse, Int32>(ref reader, this, out _count); break;
				case "indices": DeserializePropertyValue<AccessorSparse, AccessorSparseIndices>(ref reader, this, out _indices); break;
				case "values": DeserializePropertyValue<AccessorSparse, AccessorSparseValues>(ref reader, this, out _values); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A typed view into a buffer view that contains raw binary data.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Accessor : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "accessor";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "bufferView";
			yield return "byteOffset";
			yield return "componentType";
			yield return "count";
			yield return "max";
			yield return "min";
			yield return "normalized";
			yield return "sparse";
			yield return "type";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "bufferView": value = FIELDINFO.From("bufferView",this, instance => instance._bufferView); return true;
				case "byteOffset": value = FIELDINFO.From("byteOffset",this, instance => instance._byteOffset ?? 0); return true;
				case "componentType": value = FIELDINFO.From("componentType",this, instance => instance._componentType); return true;
				case "count": value = FIELDINFO.From("count",this, instance => instance._count); return true;
				case "max": value = FIELDINFO.From("max",this, instance => instance._max); return true;
				case "min": value = FIELDINFO.From("min",this, instance => instance._min); return true;
				case "normalized": value = FIELDINFO.From("normalized",this, instance => instance._normalized ?? false); return true;
				case "sparse": value = FIELDINFO.From("sparse",this, instance => instance._sparse); return true;
				case "type": value = FIELDINFO.From("type",this, instance => instance._type); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32? _bufferView;
		
		private const Int32 _byteOffsetDefault = 0;
		private const Int32 _byteOffsetMinimum = 0;
		private Int32? _byteOffset = _byteOffsetDefault;
		
		private EncodingType _componentType;
		
		private const Int32 _countMinimum = 1;
		private Int32 _count;
		
		private const int _maxMinItems = 1;
		private const int _maxMaxItems = 16;
		private List<Double> _max;
		
		private const int _minMinItems = 1;
		private const int _minMaxItems = 16;
		private List<Double> _min;
		
		private static readonly Boolean _normalizedDefault = false;
		private Boolean? _normalized = _normalizedDefault;
		
		private AccessorSparse _sparse;
		
		private String _type;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "bufferView", _bufferView);
			SerializeProperty(writer, "byteOffset", _byteOffset, _byteOffsetDefault);
			SerializePropertyEnumValue<EncodingType>(writer, "componentType", _componentType);
			SerializeProperty(writer, "count", _count);
			SerializeProperty(writer, "max", _max, _maxMinItems);
			SerializeProperty(writer, "min", _min, _minMinItems);
			SerializeProperty(writer, "normalized", _normalized, _normalizedDefault);
			SerializePropertyObject(writer, "sparse", _sparse);
			SerializeProperty(writer, "type", _type);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "bufferView": DeserializePropertyValue<Accessor, Int32?>(ref reader, this, out _bufferView); break;
				case "byteOffset": DeserializePropertyValue<Accessor, Int32?>(ref reader, this, out _byteOffset); break;
				case "componentType": _componentType = DeserializePropertyValue<EncodingType>(ref reader); break;
				case "count": DeserializePropertyValue<Accessor, Int32>(ref reader, this, out _count); break;
				case "max": DeserializePropertyList<Accessor, Double>(ref reader, this, _max); break;
				case "min": DeserializePropertyList<Accessor, Double>(ref reader, this, _min); break;
				case "normalized": DeserializePropertyValue<Accessor, Boolean?>(ref reader, this, out _normalized); break;
				case "sparse": DeserializePropertyValue<Accessor, AccessorSparse>(ref reader, this, out _sparse); break;
				case "type": DeserializePropertyValue<Accessor, String>(ref reader, this, out _type); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// The descriptor of the animated property.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class AnimationChannelTarget : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "target";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "node";
			yield return "path";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "node": value = FIELDINFO.From("node",this, instance => instance._node); return true;
				case "path": value = FIELDINFO.From("path",this, instance => instance._path); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32? _node;
		
		private PropertyPath _path;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "node", _node);
			SerializePropertyEnumSymbol<PropertyPath>(writer, "path", _path);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "node": DeserializePropertyValue<AnimationChannelTarget, Int32?>(ref reader, this, out _node); break;
				case "path": _path = DeserializePropertyValue<PropertyPath>(ref reader); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// An animation channel combines an animation sampler with a target property being animated.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class AnimationChannel : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "channel";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "sampler";
			yield return "target";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "sampler": value = FIELDINFO.From("sampler",this, instance => instance._sampler); return true;
				case "target": value = FIELDINFO.From("target",this, instance => instance._target); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32 _sampler;
		
		private AnimationChannelTarget _target;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "sampler", _sampler);
			SerializePropertyObject(writer, "target", _target);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "sampler": DeserializePropertyValue<AnimationChannel, Int32>(ref reader, this, out _sampler); break;
				case "target": DeserializePropertyValue<AnimationChannel, AnimationChannelTarget>(ref reader, this, out _target); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// An animation sampler combines timestamps with a sequence of output values and defines an interpolation algorithm.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class AnimationSampler : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "sampler";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "input";
			yield return "interpolation";
			yield return "output";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "input": value = FIELDINFO.From("input",this, instance => instance._input); return true;
				case "interpolation": value = FIELDINFO.From("interpolation",this, instance => instance._interpolation ?? AnimationInterpolationMode.LINEAR); return true;
				case "output": value = FIELDINFO.From("output",this, instance => instance._output); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32 _input;
		
		private const AnimationInterpolationMode _interpolationDefault = AnimationInterpolationMode.LINEAR;
		private AnimationInterpolationMode? _interpolation = _interpolationDefault;
		
		private Int32 _output;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "input", _input);
			SerializePropertyEnumSymbol<AnimationInterpolationMode>(writer, "interpolation", _interpolation, _interpolationDefault);
			SerializeProperty(writer, "output", _output);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "input": DeserializePropertyValue<AnimationSampler, Int32>(ref reader, this, out _input); break;
				case "interpolation": _interpolation = DeserializePropertyValue<AnimationInterpolationMode>(ref reader); break;
				case "output": DeserializePropertyValue<AnimationSampler, Int32>(ref reader, this, out _output); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A keyframe animation.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Animation : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "animation";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "channels";
			yield return "samplers";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "channels": value = FIELDINFO.From("channels",this, instance => instance._channels); return true;
				case "samplers": value = FIELDINFO.From("samplers",this, instance => instance._samplers); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const int _channelsMinItems = 1;
		private ChildrenList<AnimationChannel,Animation> _channels;
		
		private const int _samplersMinItems = 1;
		private ChildrenList<AnimationSampler,Animation> _samplers;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "channels", _channels, _channelsMinItems);
			SerializeProperty(writer, "samplers", _samplers, _samplersMinItems);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "channels": DeserializePropertyList<Animation, AnimationChannel>(ref reader, this, _channels); break;
				case "samplers": DeserializePropertyList<Animation, AnimationSampler>(ref reader, this, _samplers); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Metadata about the glTF asset.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Asset : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "asset";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "copyright";
			yield return "generator";
			yield return "minVersion";
			yield return "version";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "copyright": value = FIELDINFO.From("copyright",this, instance => instance._copyright); return true;
				case "generator": value = FIELDINFO.From("generator",this, instance => instance._generator); return true;
				case "minVersion": value = FIELDINFO.From("minVersion",this, instance => instance._minVersion); return true;
				case "version": value = FIELDINFO.From("version",this, instance => instance._version); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private String _copyright;
		
		private String _generator;
		
		private String _minVersion;
		
		private String _version;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "copyright", _copyright);
			SerializeProperty(writer, "generator", _generator);
			SerializeProperty(writer, "minVersion", _minVersion);
			SerializeProperty(writer, "version", _version);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "copyright": DeserializePropertyValue<Asset, String>(ref reader, this, out _copyright); break;
				case "generator": DeserializePropertyValue<Asset, String>(ref reader, this, out _generator); break;
				case "minVersion": DeserializePropertyValue<Asset, String>(ref reader, this, out _minVersion); break;
				case "version": DeserializePropertyValue<Asset, String>(ref reader, this, out _version); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A buffer points to binary geometry, animation, or skins.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Buffer : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "buffer";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "byteLength";
			yield return "uri";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "byteLength": value = FIELDINFO.From("byteLength",this, instance => instance._byteLength); return true;
				case "uri": value = FIELDINFO.From("uri",this, instance => instance._uri); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const Int32 _byteLengthMinimum = 1;
		private Int32 _byteLength;
		
		private String _uri;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "byteLength", _byteLength);
			SerializeProperty(writer, "uri", _uri);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "byteLength": DeserializePropertyValue<Buffer, Int32>(ref reader, this, out _byteLength); break;
				case "uri": DeserializePropertyValue<Buffer, String>(ref reader, this, out _uri); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A view into a buffer generally representing a subset of the buffer.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class BufferView : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "bufferView";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "buffer";
			yield return "byteLength";
			yield return "byteOffset";
			yield return "byteStride";
			yield return "target";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "buffer": value = FIELDINFO.From("buffer",this, instance => instance._buffer); return true;
				case "byteLength": value = FIELDINFO.From("byteLength",this, instance => instance._byteLength); return true;
				case "byteOffset": value = FIELDINFO.From("byteOffset",this, instance => instance._byteOffset ?? 0); return true;
				case "byteStride": value = FIELDINFO.From("byteStride",this, instance => instance._byteStride); return true;
				case "target": value = FIELDINFO.From("target",this, instance => instance._target); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32 _buffer;
		
		private const Int32 _byteLengthMinimum = 1;
		private Int32 _byteLength;
		
		private const Int32 _byteOffsetDefault = 0;
		private const Int32 _byteOffsetMinimum = 0;
		private Int32? _byteOffset = _byteOffsetDefault;
		
		private const Int32 _byteStrideMinimum = 4;
		private const Int32 _byteStrideMaximum = 252;
		private Int32? _byteStride;
		
		private BufferMode? _target;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "buffer", _buffer);
			SerializeProperty(writer, "byteLength", _byteLength);
			SerializeProperty(writer, "byteOffset", _byteOffset, _byteOffsetDefault);
			SerializeProperty(writer, "byteStride", _byteStride);
			SerializePropertyEnumValue<BufferMode>(writer, "target", _target);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "buffer": DeserializePropertyValue<BufferView, Int32>(ref reader, this, out _buffer); break;
				case "byteLength": DeserializePropertyValue<BufferView, Int32>(ref reader, this, out _byteLength); break;
				case "byteOffset": DeserializePropertyValue<BufferView, Int32?>(ref reader, this, out _byteOffset); break;
				case "byteStride": DeserializePropertyValue<BufferView, Int32?>(ref reader, this, out _byteStride); break;
				case "target": _target = DeserializePropertyValue<BufferMode>(ref reader); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// An orthographic camera containing properties to create an orthographic projection matrix.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class CameraOrthographic : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "orthographic";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "xmag";
			yield return "ymag";
			yield return "zfar";
			yield return "znear";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "xmag": value = FIELDINFO.From("xmag",this, instance => instance._xmag); return true;
				case "ymag": value = FIELDINFO.From("ymag",this, instance => instance._ymag); return true;
				case "zfar": value = FIELDINFO.From("zfar",this, instance => instance._zfar); return true;
				case "znear": value = FIELDINFO.From("znear",this, instance => instance._znear); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Double _xmag;
		
		private Double _ymag;
		
		private const Double _zfarExclusiveMinimum = 0;
		private Double _zfar;
		
		private const Double _znearMinimum = 0;
		private Double _znear;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "xmag", _xmag);
			SerializeProperty(writer, "ymag", _ymag);
			SerializeProperty(writer, "zfar", _zfar);
			SerializeProperty(writer, "znear", _znear);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "xmag": DeserializePropertyValue<CameraOrthographic, Double>(ref reader, this, out _xmag); break;
				case "ymag": DeserializePropertyValue<CameraOrthographic, Double>(ref reader, this, out _ymag); break;
				case "zfar": DeserializePropertyValue<CameraOrthographic, Double>(ref reader, this, out _zfar); break;
				case "znear": DeserializePropertyValue<CameraOrthographic, Double>(ref reader, this, out _znear); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A perspective camera containing properties to create a perspective projection matrix.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class CameraPerspective : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "perspective";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "aspectRatio";
			yield return "yfov";
			yield return "zfar";
			yield return "znear";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "aspectRatio": value = FIELDINFO.From("aspectRatio",this, instance => instance._aspectRatio); return true;
				case "yfov": value = FIELDINFO.From("yfov",this, instance => instance._yfov); return true;
				case "zfar": value = FIELDINFO.From("zfar",this, instance => instance._zfar); return true;
				case "znear": value = FIELDINFO.From("znear",this, instance => instance._znear); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const Double _aspectRatioExclusiveMinimum = 0;
		private Double? _aspectRatio;
		
		private const Double _yfovExclusiveMinimum = 0;
		private Double _yfov;
		
		private const Double _zfarExclusiveMinimum = 0;
		private Double? _zfar;
		
		private const Double _znearExclusiveMinimum = 0;
		private Double _znear;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "aspectRatio", _aspectRatio);
			SerializeProperty(writer, "yfov", _yfov);
			SerializeProperty(writer, "zfar", _zfar);
			SerializeProperty(writer, "znear", _znear);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "aspectRatio": DeserializePropertyValue<CameraPerspective, Double?>(ref reader, this, out _aspectRatio); break;
				case "yfov": DeserializePropertyValue<CameraPerspective, Double>(ref reader, this, out _yfov); break;
				case "zfar": DeserializePropertyValue<CameraPerspective, Double?>(ref reader, this, out _zfar); break;
				case "znear": DeserializePropertyValue<CameraPerspective, Double>(ref reader, this, out _znear); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A camera's projection.
	/// A node **MAY** reference a camera to apply a transform to place the camera in the scene.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Camera : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "camera";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "orthographic";
			yield return "perspective";
			yield return "type";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "orthographic": value = FIELDINFO.From("orthographic",this, instance => instance._orthographic); return true;
				case "perspective": value = FIELDINFO.From("perspective",this, instance => instance._perspective); return true;
				case "type": value = FIELDINFO.From("type",this, instance => instance._type); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private CameraOrthographic _orthographic;
		
		private CameraPerspective _perspective;
		
		private CameraType _type;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializePropertyObject(writer, "orthographic", _orthographic);
			SerializePropertyObject(writer, "perspective", _perspective);
			SerializePropertyEnumSymbol<CameraType>(writer, "type", _type);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "orthographic": DeserializePropertyValue<Camera, CameraOrthographic>(ref reader, this, out _orthographic); break;
				case "perspective": DeserializePropertyValue<Camera, CameraPerspective>(ref reader, this, out _perspective); break;
				case "type": _type = DeserializePropertyValue<CameraType>(ref reader); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Reference to a texture.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class TextureInfo : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "textureInfo";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "index";
			yield return "texCoord";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "index": value = FIELDINFO.From("index",this, instance => instance._index); return true;
				case "texCoord": value = FIELDINFO.From("texCoord",this, instance => instance._texCoord ?? 0); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32 _index;
		
		private const Int32 _texCoordDefault = 0;
		private const Int32 _texCoordMinimum = 0;
		private Int32? _texCoord = _texCoordDefault;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "index", _index);
			SerializeProperty(writer, "texCoord", _texCoord, _texCoordDefault);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "index": DeserializePropertyValue<TextureInfo, Int32>(ref reader, this, out _index); break;
				case "texCoord": DeserializePropertyValue<TextureInfo, Int32?>(ref reader, this, out _texCoord); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class MaterialPBRMetallicRoughness : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "pbrMetallicRoughness";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "baseColorFactor";
			yield return "baseColorTexture";
			yield return "metallicFactor";
			yield return "metallicRoughnessTexture";
			yield return "roughnessFactor";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "baseColorFactor": value = FIELDINFO.From("baseColorFactor",this, instance => instance._baseColorFactor ?? Vector4.One); return true;
				case "baseColorTexture": value = FIELDINFO.From("baseColorTexture",this, instance => instance._baseColorTexture); return true;
				case "metallicFactor": value = FIELDINFO.From("metallicFactor",this, instance => instance._metallicFactor ?? 1); return true;
				case "metallicRoughnessTexture": value = FIELDINFO.From("metallicRoughnessTexture",this, instance => instance._metallicRoughnessTexture); return true;
				case "roughnessFactor": value = FIELDINFO.From("roughnessFactor",this, instance => instance._roughnessFactor ?? 1); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private static readonly Vector4 _baseColorFactorDefault = Vector4.One;
		private Vector4? _baseColorFactor = _baseColorFactorDefault;
		
		private TextureInfo _baseColorTexture;
		
		private const Double _metallicFactorDefault = 1;
		private const Double _metallicFactorMinimum = 0;
		private const Double _metallicFactorMaximum = 1;
		private Double? _metallicFactor = _metallicFactorDefault;
		
		private TextureInfo _metallicRoughnessTexture;
		
		private const Double _roughnessFactorDefault = 1;
		private const Double _roughnessFactorMinimum = 0;
		private const Double _roughnessFactorMaximum = 1;
		private Double? _roughnessFactor = _roughnessFactorDefault;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "baseColorFactor", _baseColorFactor, _baseColorFactorDefault);
			SerializePropertyObject(writer, "baseColorTexture", _baseColorTexture);
			SerializeProperty(writer, "metallicFactor", _metallicFactor, _metallicFactorDefault);
			SerializePropertyObject(writer, "metallicRoughnessTexture", _metallicRoughnessTexture);
			SerializeProperty(writer, "roughnessFactor", _roughnessFactor, _roughnessFactorDefault);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "baseColorFactor": DeserializePropertyValue<MaterialPBRMetallicRoughness, Vector4?>(ref reader, this, out _baseColorFactor); break;
				case "baseColorTexture": DeserializePropertyValue<MaterialPBRMetallicRoughness, TextureInfo>(ref reader, this, out _baseColorTexture); break;
				case "metallicFactor": DeserializePropertyValue<MaterialPBRMetallicRoughness, Double?>(ref reader, this, out _metallicFactor); break;
				case "metallicRoughnessTexture": DeserializePropertyValue<MaterialPBRMetallicRoughness, TextureInfo>(ref reader, this, out _metallicRoughnessTexture); break;
				case "roughnessFactor": DeserializePropertyValue<MaterialPBRMetallicRoughness, Double?>(ref reader, this, out _roughnessFactor); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class MaterialNormalTextureInfo : TextureInfo
	{
	
		#region reflection
	
		public const string SCHEMANAME = "normalTextureInfo";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "scale";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "scale": value = FIELDINFO.From("scale",this, instance => instance._scale ?? 1); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const Double _scaleDefault = 1;
		private Double? _scale = _scaleDefault;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "scale", _scale, _scaleDefault);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "scale": DeserializePropertyValue<MaterialNormalTextureInfo, Double?>(ref reader, this, out _scale); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class MaterialOcclusionTextureInfo : TextureInfo
	{
	
		#region reflection
	
		public const string SCHEMANAME = "occlusionTextureInfo";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "strength";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "strength": value = FIELDINFO.From("strength",this, instance => instance._strength ?? 1); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const Double _strengthDefault = 1;
		private const Double _strengthMinimum = 0;
		private const Double _strengthMaximum = 1;
		private Double? _strength = _strengthDefault;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "strength", _strength, _strengthDefault);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "strength": DeserializePropertyValue<MaterialOcclusionTextureInfo, Double?>(ref reader, this, out _strength); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// The material appearance of a primitive.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Material : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "material";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "alphaCutoff";
			yield return "alphaMode";
			yield return "doubleSided";
			yield return "emissiveFactor";
			yield return "emissiveTexture";
			yield return "normalTexture";
			yield return "occlusionTexture";
			yield return "pbrMetallicRoughness";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "alphaCutoff": value = FIELDINFO.From("alphaCutoff",this, instance => instance._alphaCutoff ?? 0.5); return true;
				case "alphaMode": value = FIELDINFO.From("alphaMode",this, instance => instance._alphaMode ?? AlphaMode.OPAQUE); return true;
				case "doubleSided": value = FIELDINFO.From("doubleSided",this, instance => instance._doubleSided ?? false); return true;
				case "emissiveFactor": value = FIELDINFO.From("emissiveFactor",this, instance => instance._emissiveFactor ?? Vector3.Zero); return true;
				case "emissiveTexture": value = FIELDINFO.From("emissiveTexture",this, instance => instance._emissiveTexture); return true;
				case "normalTexture": value = FIELDINFO.From("normalTexture",this, instance => instance._normalTexture); return true;
				case "occlusionTexture": value = FIELDINFO.From("occlusionTexture",this, instance => instance._occlusionTexture); return true;
				case "pbrMetallicRoughness": value = FIELDINFO.From("pbrMetallicRoughness",this, instance => instance._pbrMetallicRoughness); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const Double _alphaCutoffDefault = 0.5;
		private const Double _alphaCutoffMinimum = 0;
		private Double? _alphaCutoff = _alphaCutoffDefault;
		
		private const AlphaMode _alphaModeDefault = AlphaMode.OPAQUE;
		private AlphaMode? _alphaMode = _alphaModeDefault;
		
		private static readonly Boolean _doubleSidedDefault = false;
		private Boolean? _doubleSided = _doubleSidedDefault;
		
		private static readonly Vector3 _emissiveFactorDefault = Vector3.Zero;
		private Vector3? _emissiveFactor = _emissiveFactorDefault;
		
		private TextureInfo _emissiveTexture;
		
		private MaterialNormalTextureInfo _normalTexture;
		
		private MaterialOcclusionTextureInfo _occlusionTexture;
		
		private MaterialPBRMetallicRoughness _pbrMetallicRoughness;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "alphaCutoff", _alphaCutoff, _alphaCutoffDefault);
			SerializePropertyEnumSymbol<AlphaMode>(writer, "alphaMode", _alphaMode, _alphaModeDefault);
			SerializeProperty(writer, "doubleSided", _doubleSided, _doubleSidedDefault);
			SerializeProperty(writer, "emissiveFactor", _emissiveFactor, _emissiveFactorDefault);
			SerializePropertyObject(writer, "emissiveTexture", _emissiveTexture);
			SerializePropertyObject(writer, "normalTexture", _normalTexture);
			SerializePropertyObject(writer, "occlusionTexture", _occlusionTexture);
			SerializePropertyObject(writer, "pbrMetallicRoughness", _pbrMetallicRoughness);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "alphaCutoff": DeserializePropertyValue<Material, Double?>(ref reader, this, out _alphaCutoff); break;
				case "alphaMode": _alphaMode = DeserializePropertyValue<AlphaMode>(ref reader); break;
				case "doubleSided": DeserializePropertyValue<Material, Boolean?>(ref reader, this, out _doubleSided); break;
				case "emissiveFactor": DeserializePropertyValue<Material, Vector3?>(ref reader, this, out _emissiveFactor); break;
				case "emissiveTexture": DeserializePropertyValue<Material, TextureInfo>(ref reader, this, out _emissiveTexture); break;
				case "normalTexture": DeserializePropertyValue<Material, MaterialNormalTextureInfo>(ref reader, this, out _normalTexture); break;
				case "occlusionTexture": DeserializePropertyValue<Material, MaterialOcclusionTextureInfo>(ref reader, this, out _occlusionTexture); break;
				case "pbrMetallicRoughness": DeserializePropertyValue<Material, MaterialPBRMetallicRoughness>(ref reader, this, out _pbrMetallicRoughness); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Geometry to be rendered with the given material.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class MeshPrimitive : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "primitive";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "attributes";
			yield return "indices";
			yield return "material";
			yield return "mode";
			yield return "targets";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "attributes": value = FIELDINFO.From("attributes",this, instance => instance._attributes); return true;
				case "indices": value = FIELDINFO.From("indices",this, instance => instance._indices); return true;
				case "material": value = FIELDINFO.From("material",this, instance => instance._material); return true;
				case "mode": value = FIELDINFO.From("mode",this, instance => instance._mode ?? (PrimitiveType)4); return true;
				case "targets": value = FIELDINFO.From("targets",this, instance => instance._targets); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Dictionary<String,Int32> _attributes;
		
		private Int32? _indices;
		
		private Int32? _material;
		
		private const PrimitiveType _modeDefault = (PrimitiveType)4;
		private PrimitiveType? _mode = _modeDefault;
		
		private const int _targetsMinItems = 1;
		private List<Dictionary<String,Int32>> _targets;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "attributes", _attributes);
			SerializeProperty(writer, "indices", _indices);
			SerializeProperty(writer, "material", _material);
			SerializePropertyEnumValue<PrimitiveType>(writer, "mode", _mode, _modeDefault);
			SerializeProperty(writer, "targets", _targets, _targetsMinItems);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "attributes": DeserializePropertyDictionary<MeshPrimitive, Int32>(ref reader, this, _attributes); break;
				case "indices": DeserializePropertyValue<MeshPrimitive, Int32?>(ref reader, this, out _indices); break;
				case "material": DeserializePropertyValue<MeshPrimitive, Int32?>(ref reader, this, out _material); break;
				case "mode": _mode = DeserializePropertyValue<PrimitiveType>(ref reader); break;
				case "targets": DeserializePropertyList<MeshPrimitive, Dictionary<String,Int32>>(ref reader, this, _targets); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A set of primitives to be rendered.
	/// Its global transform is defined by a node that references it.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Mesh : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "mesh";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "primitives";
			yield return "weights";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "primitives": value = FIELDINFO.From("primitives",this, instance => instance._primitives); return true;
				case "weights": value = FIELDINFO.From("weights",this, instance => instance._weights); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const int _primitivesMinItems = 1;
		private ChildrenList<MeshPrimitive,Mesh> _primitives;
		
		private const int _weightsMinItems = 1;
		private List<Double> _weights;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "primitives", _primitives, _primitivesMinItems);
			SerializeProperty(writer, "weights", _weights, _weightsMinItems);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "primitives": DeserializePropertyList<Mesh, MeshPrimitive>(ref reader, this, _primitives); break;
				case "weights": DeserializePropertyList<Mesh, Double>(ref reader, this, _weights); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A node in the node hierarchy.
	/// When the node contains `skin`, all `mesh.primitives` **MUST** contain `JOINTS_0` and `WEIGHTS_0` attributes.
	/// A node **MAY** have either a `matrix` or any combination of `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then the rotation, and then the translation. If none are provided, the transform is the identity. When a node is targeted for animation (referenced by an animation.channel.target), `matrix` **MUST NOT** be present.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Node : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "node";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "camera";
			yield return "children";
			yield return "matrix";
			yield return "mesh";
			yield return "rotation";
			yield return "scale";
			yield return "skin";
			yield return "translation";
			yield return "weights";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "camera": value = FIELDINFO.From("camera",this, instance => instance._camera); return true;
				case "children": value = FIELDINFO.From("children",this, instance => instance._children); return true;
				case "matrix": value = FIELDINFO.From("matrix",this, instance => instance._matrix ?? System.Numerics.Matrix4x4.Identity); return true;
				case "mesh": value = FIELDINFO.From("mesh",this, instance => instance._mesh); return true;
				case "rotation": value = FIELDINFO.From("rotation",this, instance => instance._rotation ?? Quaternion.Identity); return true;
				case "scale": value = FIELDINFO.From("scale",this, instance => instance._scale ?? Vector3.One); return true;
				case "skin": value = FIELDINFO.From("skin",this, instance => instance._skin); return true;
				case "translation": value = FIELDINFO.From("translation",this, instance => instance._translation ?? Vector3.Zero); return true;
				case "weights": value = FIELDINFO.From("weights",this, instance => instance._weights); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32? _camera;
		
		private const int _childrenMinItems = 1;
		private List<Int32> _children;
		
		private static readonly Matrix4x4 _matrixDefault = System.Numerics.Matrix4x4.Identity;
		private Matrix4x4? _matrix = _matrixDefault;
		
		private Int32? _mesh;
		
		private static readonly Quaternion _rotationDefault = Quaternion.Identity;
		private Quaternion? _rotation = _rotationDefault;
		
		private static readonly Vector3 _scaleDefault = Vector3.One;
		private Vector3? _scale = _scaleDefault;
		
		private Int32? _skin;
		
		private static readonly Vector3 _translationDefault = Vector3.Zero;
		private Vector3? _translation = _translationDefault;
		
		private const int _weightsMinItems = 1;
		private List<Double> _weights;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "camera", _camera);
			SerializeProperty(writer, "children", _children, _childrenMinItems);
			SerializeProperty(writer, "matrix", _matrix, _matrixDefault);
			SerializeProperty(writer, "mesh", _mesh);
			SerializeProperty(writer, "rotation", _rotation, _rotationDefault);
			SerializeProperty(writer, "scale", _scale, _scaleDefault);
			SerializeProperty(writer, "skin", _skin);
			SerializeProperty(writer, "translation", _translation, _translationDefault);
			SerializeProperty(writer, "weights", _weights, _weightsMinItems);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "camera": DeserializePropertyValue<Node, Int32?>(ref reader, this, out _camera); break;
				case "children": DeserializePropertyList<Node, Int32>(ref reader, this, _children); break;
				case "matrix": DeserializePropertyValue<Node, Matrix4x4?>(ref reader, this, out _matrix); break;
				case "mesh": DeserializePropertyValue<Node, Int32?>(ref reader, this, out _mesh); break;
				case "rotation": DeserializePropertyValue<Node, Quaternion?>(ref reader, this, out _rotation); break;
				case "scale": DeserializePropertyValue<Node, Vector3?>(ref reader, this, out _scale); break;
				case "skin": DeserializePropertyValue<Node, Int32?>(ref reader, this, out _skin); break;
				case "translation": DeserializePropertyValue<Node, Vector3?>(ref reader, this, out _translation); break;
				case "weights": DeserializePropertyList<Node, Double>(ref reader, this, _weights); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Texture sampler properties for filtering and wrapping modes.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class TextureSampler : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "sampler";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "magFilter";
			yield return "minFilter";
			yield return "wrapS";
			yield return "wrapT";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "magFilter": value = FIELDINFO.From("magFilter",this, instance => instance._magFilter); return true;
				case "minFilter": value = FIELDINFO.From("minFilter",this, instance => instance._minFilter); return true;
				case "wrapS": value = FIELDINFO.From("wrapS",this, instance => instance._wrapS ?? (TextureWrapMode)10497); return true;
				case "wrapT": value = FIELDINFO.From("wrapT",this, instance => instance._wrapT ?? (TextureWrapMode)10497); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private TextureInterpolationFilter? _magFilter;
		
		private TextureMipMapFilter? _minFilter;
		
		private const TextureWrapMode _wrapSDefault = (TextureWrapMode)10497;
		private TextureWrapMode? _wrapS = _wrapSDefault;
		
		private const TextureWrapMode _wrapTDefault = (TextureWrapMode)10497;
		private TextureWrapMode? _wrapT = _wrapTDefault;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializePropertyEnumValue<TextureInterpolationFilter>(writer, "magFilter", _magFilter);
			SerializePropertyEnumValue<TextureMipMapFilter>(writer, "minFilter", _minFilter);
			SerializePropertyEnumValue<TextureWrapMode>(writer, "wrapS", _wrapS, _wrapSDefault);
			SerializePropertyEnumValue<TextureWrapMode>(writer, "wrapT", _wrapT, _wrapTDefault);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "magFilter": _magFilter = DeserializePropertyValue<TextureInterpolationFilter>(ref reader); break;
				case "minFilter": _minFilter = DeserializePropertyValue<TextureMipMapFilter>(ref reader); break;
				case "wrapS": _wrapS = DeserializePropertyValue<TextureWrapMode>(ref reader); break;
				case "wrapT": _wrapT = DeserializePropertyValue<TextureWrapMode>(ref reader); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// The root nodes of a scene.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Scene : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "scene";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "nodes";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "nodes": value = FIELDINFO.From("nodes",this, instance => instance._nodes); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private const int _nodesMinItems = 1;
		private List<Int32> _nodes;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "nodes", _nodes, _nodesMinItems);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "nodes": DeserializePropertyList<Scene, Int32>(ref reader, this, _nodes); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Joints and matrices defining a skin.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Skin : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "skin";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "inverseBindMatrices";
			yield return "joints";
			yield return "skeleton";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "inverseBindMatrices": value = FIELDINFO.From("inverseBindMatrices",this, instance => instance._inverseBindMatrices); return true;
				case "joints": value = FIELDINFO.From("joints",this, instance => instance._joints); return true;
				case "skeleton": value = FIELDINFO.From("skeleton",this, instance => instance._skeleton); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32? _inverseBindMatrices;
		
		private const int _jointsMinItems = 1;
		private List<Int32> _joints;
		
		private Int32? _skeleton;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "inverseBindMatrices", _inverseBindMatrices);
			SerializeProperty(writer, "joints", _joints, _jointsMinItems);
			SerializeProperty(writer, "skeleton", _skeleton);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "inverseBindMatrices": DeserializePropertyValue<Skin, Int32?>(ref reader, this, out _inverseBindMatrices); break;
				case "joints": DeserializePropertyList<Skin, Int32>(ref reader, this, _joints); break;
				case "skeleton": DeserializePropertyValue<Skin, Int32?>(ref reader, this, out _skeleton); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// A texture and its sampler.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Texture : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "texture";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "sampler";
			yield return "source";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "sampler": value = FIELDINFO.From("sampler",this, instance => instance._sampler); return true;
				case "source": value = FIELDINFO.From("source",this, instance => instance._source); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32? _sampler;
		
		private Int32? _source;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "sampler", _sampler);
			SerializeProperty(writer, "source", _source);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "sampler": DeserializePropertyValue<Texture, Int32?>(ref reader, this, out _sampler); break;
				case "source": DeserializePropertyValue<Texture, Int32?>(ref reader, this, out _source); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// The root object for a glTF asset.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class ModelRoot : ExtraProperties
	{
	
		#region reflection
	
		public const string SCHEMANAME = "glTF";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "asset";
			yield return "extensionsRequired";
			yield return "extensionsUsed";
			yield return "accessors";
			yield return "animations";
			yield return "bufferViews";
			yield return "buffers";
			yield return "cameras";
			yield return "images";
			yield return "materials";
			yield return "meshes";
			yield return "nodes";
			yield return "samplers";
			yield return "scene";
			yield return "scenes";
			yield return "skins";
			yield return "textures";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "asset": value = FIELDINFO.From("asset",this, instance => instance._asset); return true;
				case "extensionsRequired": value = FIELDINFO.From("extensionsRequired",this, instance => instance._extensionsRequired); return true;
				case "extensionsUsed": value = FIELDINFO.From("extensionsUsed",this, instance => instance._extensionsUsed); return true;
				case "accessors": value = FIELDINFO.From("accessors",this, instance => instance._accessors); return true;
				case "animations": value = FIELDINFO.From("animations",this, instance => instance._animations); return true;
				case "bufferViews": value = FIELDINFO.From("bufferViews",this, instance => instance._bufferViews); return true;
				case "buffers": value = FIELDINFO.From("buffers",this, instance => instance._buffers); return true;
				case "cameras": value = FIELDINFO.From("cameras",this, instance => instance._cameras); return true;
				case "images": value = FIELDINFO.From("images",this, instance => instance._images); return true;
				case "materials": value = FIELDINFO.From("materials",this, instance => instance._materials); return true;
				case "meshes": value = FIELDINFO.From("meshes",this, instance => instance._meshes); return true;
				case "nodes": value = FIELDINFO.From("nodes",this, instance => instance._nodes); return true;
				case "samplers": value = FIELDINFO.From("samplers",this, instance => instance._samplers); return true;
				case "scene": value = FIELDINFO.From("scene",this, instance => instance._scene); return true;
				case "scenes": value = FIELDINFO.From("scenes",this, instance => instance._scenes); return true;
				case "skins": value = FIELDINFO.From("skins",this, instance => instance._skins); return true;
				case "textures": value = FIELDINFO.From("textures",this, instance => instance._textures); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Asset _asset;
		
		private const int _extensionsRequiredMinItems = 1;
		private List<String> _extensionsRequired;
		
		private const int _extensionsUsedMinItems = 1;
		private List<String> _extensionsUsed;
		
		private const int _accessorsMinItems = 1;
		private ChildrenList<Accessor,ModelRoot> _accessors;
		
		private const int _animationsMinItems = 1;
		private ChildrenList<Animation,ModelRoot> _animations;
		
		private const int _bufferViewsMinItems = 1;
		private ChildrenList<BufferView,ModelRoot> _bufferViews;
		
		private const int _buffersMinItems = 1;
		private ChildrenList<Buffer,ModelRoot> _buffers;
		
		private const int _camerasMinItems = 1;
		private ChildrenList<Camera,ModelRoot> _cameras;
		
		private const int _imagesMinItems = 1;
		private ChildrenList<Image,ModelRoot> _images;
		
		private const int _materialsMinItems = 1;
		private ChildrenList<Material,ModelRoot> _materials;
		
		private const int _meshesMinItems = 1;
		private ChildrenList<Mesh,ModelRoot> _meshes;
		
		private const int _nodesMinItems = 1;
		private ChildrenList<Node,ModelRoot> _nodes;
		
		private const int _samplersMinItems = 1;
		private ChildrenList<TextureSampler,ModelRoot> _samplers;
		
		private Int32? _scene;
		
		private const int _scenesMinItems = 1;
		private ChildrenList<Scene,ModelRoot> _scenes;
		
		private const int _skinsMinItems = 1;
		private ChildrenList<Skin,ModelRoot> _skins;
		
		private const int _texturesMinItems = 1;
		private ChildrenList<Texture,ModelRoot> _textures;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializePropertyObject(writer, "asset", _asset);
			SerializeProperty(writer, "extensionsRequired", _extensionsRequired, _extensionsRequiredMinItems);
			SerializeProperty(writer, "extensionsUsed", _extensionsUsed, _extensionsUsedMinItems);
			SerializeProperty(writer, "accessors", _accessors, _accessorsMinItems);
			SerializeProperty(writer, "animations", _animations, _animationsMinItems);
			SerializeProperty(writer, "bufferViews", _bufferViews, _bufferViewsMinItems);
			SerializeProperty(writer, "buffers", _buffers, _buffersMinItems);
			SerializeProperty(writer, "cameras", _cameras, _camerasMinItems);
			SerializeProperty(writer, "images", _images, _imagesMinItems);
			SerializeProperty(writer, "materials", _materials, _materialsMinItems);
			SerializeProperty(writer, "meshes", _meshes, _meshesMinItems);
			SerializeProperty(writer, "nodes", _nodes, _nodesMinItems);
			SerializeProperty(writer, "samplers", _samplers, _samplersMinItems);
			SerializeProperty(writer, "scene", _scene);
			SerializeProperty(writer, "scenes", _scenes, _scenesMinItems);
			SerializeProperty(writer, "skins", _skins, _skinsMinItems);
			SerializeProperty(writer, "textures", _textures, _texturesMinItems);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "asset": DeserializePropertyValue<ModelRoot, Asset>(ref reader, this, out _asset); break;
				case "extensionsRequired": DeserializePropertyList<ModelRoot, String>(ref reader, this, _extensionsRequired); break;
				case "extensionsUsed": DeserializePropertyList<ModelRoot, String>(ref reader, this, _extensionsUsed); break;
				case "accessors": DeserializePropertyList<ModelRoot, Accessor>(ref reader, this, _accessors); break;
				case "animations": DeserializePropertyList<ModelRoot, Animation>(ref reader, this, _animations); break;
				case "bufferViews": DeserializePropertyList<ModelRoot, BufferView>(ref reader, this, _bufferViews); break;
				case "buffers": DeserializePropertyList<ModelRoot, Buffer>(ref reader, this, _buffers); break;
				case "cameras": DeserializePropertyList<ModelRoot, Camera>(ref reader, this, _cameras); break;
				case "images": DeserializePropertyList<ModelRoot, Image>(ref reader, this, _images); break;
				case "materials": DeserializePropertyList<ModelRoot, Material>(ref reader, this, _materials); break;
				case "meshes": DeserializePropertyList<ModelRoot, Mesh>(ref reader, this, _meshes); break;
				case "nodes": DeserializePropertyList<ModelRoot, Node>(ref reader, this, _nodes); break;
				case "samplers": DeserializePropertyList<ModelRoot, TextureSampler>(ref reader, this, _samplers); break;
				case "scene": DeserializePropertyValue<ModelRoot, Int32?>(ref reader, this, out _scene); break;
				case "scenes": DeserializePropertyList<ModelRoot, Scene>(ref reader, this, _scenes); break;
				case "skins": DeserializePropertyList<ModelRoot, Skin>(ref reader, this, _skins); break;
				case "textures": DeserializePropertyList<ModelRoot, Texture>(ref reader, this, _textures); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

	/// <summary>
	/// Image data used to create a texture. Image **MAY** be referenced by an URI (or IRI) or a buffer view index.
	/// </summary>
	#if NET6_0_OR_GREATER
	[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors)]
	#endif
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("SharpGLTF.CodeGen", "1.0.0.0")]
	partial class Image : LogicalChildOfRoot
	{
	
		#region reflection
	
		public const string SCHEMANAME = "image";
		protected override string GetSchemaName() => SCHEMANAME;
	
		protected override IEnumerable<string> ReflectFieldsNames()
		{
			yield return "bufferView";
			yield return "mimeType";
			yield return "uri";
			foreach(var f in base.ReflectFieldsNames()) yield return f;
		}
		protected override bool TryReflectField(string name, out FIELDINFO value)
		{
			switch(name)
			{
				case "bufferView": value = FIELDINFO.From("bufferView",this, instance => instance._bufferView); return true;
				case "mimeType": value = FIELDINFO.From("mimeType",this, instance => instance._mimeType); return true;
				case "uri": value = FIELDINFO.From("uri",this, instance => instance._uri); return true;
				default: return base.TryReflectField(name, out value);
			}
		}
	
		#endregion
	
		#region data
	
		private Int32? _bufferView;
		
		private String _mimeType;
		
		private String _uri;
		
		#endregion
	
		#region serialization
	
		protected override void SerializeProperties(JSONWRITER writer)
		{
			base.SerializeProperties(writer);
			SerializeProperty(writer, "bufferView", _bufferView);
			SerializeProperty(writer, "mimeType", _mimeType);
			SerializeProperty(writer, "uri", _uri);
		}
	
		protected override void DeserializeProperty(string jsonPropertyName, ref JSONREADER reader)
		{
			switch (jsonPropertyName)
			{
				case "bufferView": DeserializePropertyValue<Image, Int32?>(ref reader, this, out _bufferView); break;
				case "mimeType": DeserializePropertyValue<Image, String>(ref reader, this, out _mimeType); break;
				case "uri": DeserializePropertyValue<Image, String>(ref reader, this, out _uri); break;
				default: base.DeserializeProperty(jsonPropertyName,ref reader); break;
			}
		}
	
		#endregion
	
	}

}
